---
title: "tidygraph"
author: "Maria Prokofieva"
date: "17/02/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      warning=FALSE,
                      message=FALSE,
                      error=FALSE
                      )
```

```{r}

#install.packages(c("igraph","graphlayouts","ggraph","ggplot2"))
#ggplot2 is part of tidyverse package,

library(igraph)
library(ggraph)
library(graphlayouts)
library(tidygraph)

```

## `tidygraph` package

### Tidy data -> Tidy network data

**Tidy data** approach relies on 3 rules which make a dataset tidy

- Each variable must have its own column.

- Each observation must have its own row.

- Each value must have its own cell.

Can we code network data in this way?

Relational data -> single *tidy* data frame ?

But

nodes data -> tidy data = tidy data frame

edges data -> tidy data = tidy data frame

2 tidy data frames -> `tbl_graph` object

## The tbl_graph object

Working with `tidygraph` is based on using `tbl_graph` objects
What is happening:

`igraph`: keep the node and edge data in a list and creating igraph objects

`tidygraph`: subclasses igraph with the `tbl_graph` class to work in a tidy manner.

- ensures that all`igraph` features will work with `tbl_graph` objects. 

To create `tbl_graph` objects use `tbl_graph()` function and providea node data.frame and an edge data.frame. It also works with : 

- data.frame

- list

- matrix 

- igraph object (`igraph`)

- network object (`network`)

- and LOTS of others (see [this](https://cran.r-project.org/web/packages/tidygraph/tidygraph.pdf))

```{r}
mtcars_matrix <- cor(t(mtcars[,c(1,3:6)]))

mtcars_clust <- hclust(dist(mtcars[,c(1,3:6)]))


mtcars_graph<-as_tbl_graph(mtcars_clust)

mtcars_graph


iris_clust <- hclust(dist(iris[1:4]))
iris_tree <- as_tbl_graph(iris_clust)
iris_tree
```

## How it works

**Old way**: 

`tidygraph` introduces new functions as well as allows to use traditional `tidyverse` functions:

`mutate_nodes()` = `mutate (..., target = 'nodes)`

`filter_edges()`= `filter (..., target = 'edges')`

`arrange(..., target = 'nodes') `

**New way**:

Use a **pointer**  to let the data object itself do all manipulation.

This pointer is changed using the `activate()`. You can use `nodes` and `edges` (from `ggraph`) or `vertices` and `links`.

```{r}
mtcars_graph %>% activate(edges)

#Can extract the active data as tibble if needed
as_tibble(mtcars_graph) %>% head()
```
Additionally, you can use `.N()`  to gain access to the node data *while manipulating the edge data*. 

or 

`.E()` to use the edge data when on the node data

or 

`.G()` to get access to the `tbl_graph` object itself.

### `tidyverse` functions 

`filter()`/`slice()` on node data remove the edges terminating at the removed nodes. 

`arrange()` on nodes changes the indexes of the to and from column in the edge data.

`dplyrs` is supported but requires rows to maintain their identity (due to relation structure). 

e.g. summarise() and do() are not allowed - the change in node and edge data

ps: you can apply them to a tibble representation of the data and then joining the result back in.

`join` is supported, but `to` and `from` column should be referencing existing nodes.

Additionally, we can use `bind_nodes()` and `bind_edges()`  to add nodes / edges to the graph. 

`bind_graphs()` combines multiple graphs in the same graph structure, but cannot create edges between the merged graphs

```{r}
library(ggraph)
graph1 <- create_notable('diamond') %>% 
    mutate(name = letters[1:4])
plot(graph1)
graph2 <- create_star(5) %>% 
    mutate(name = letters[4:8])
plot(graph2)

# Plot
graph1 %>% bind_graphs(graph2) %>% 
    ggraph(layout = 'kk') + 
    geom_edge_link() + 
    geom_node_point(size = 8, colour = 'steelblue') +
    geom_node_text(aes(label = name), colour = 'white', vjust = 0.4) + 
    ggtitle('Binding graphs using `bind_graphs`') + 
    theme_graph()
```
vs

`graph_join()`merges nodes using a `full_join()` and keeps the individual edges from both graphs

```{r}
graph1 %>% graph_join(graph2) %>% 
    ggraph(layout = 'kk') + 
    geom_edge_link() + 
    geom_node_point(size = 8, colour = 'steelblue') +
    geom_node_text(aes(label = name), colour = 'white', vjust = 0.4) + 
    ggtitle('Joining graphs using `graph_join`') + 
    theme_graph()
```
### Centrality and Clustering
